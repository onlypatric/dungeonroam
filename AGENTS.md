## ðŸ“š Library / API Reference Matrix for Minecraft Plugin Dev

| Domain / Purpose                                                          | Library / API Name                                                                                                                          | What it helps with / Why use it                                                                                                   |
| ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| **Base abstraction & multi-version compatibility / NMS avoidance**        | **BKCommonLib**                                                                                                                             | Provides many utilities + abstractions over Minecraft server internals (NMS, tasks, entity / block / world operations), letting you avoid writing version-specific, fragile NMS code. Useful when your plugin manipulates entities, teleports, spawns mobs, or does low-level world/entity work. |
| **Configuration management**                                              | **ConfigLib**, or other config libraries (e.g. **Configurate**, **okaeri-configs**)                                                        | Simplifies reading/writing plugin configuration (YAML or other formats), mapping config files to Java objects. Great for zone definitions, loot tables, kit definitions, spawn rules, etc. |
| **Command handling / command framework**                                  | **ACF (Annotation-based Command Framework)**, **Cloud Command Framework**, **CommandAPI**, **LiteCommands**, **Commodore**                  | Helps implement commands (kit selection, teleport, admin commands, etc.) with minimal boilerplate, clean syntax (annotations or builders), built-in permissions and suggestions; reduces manual command-parsing. |
| **GUI / Inventory-based menus / UI**                                      | **InventoryGui**, **Canvas**, **triumph-gui**, **AnvilGUI** (and similar GUI libs)                                                         | Useful if plugin offers in-game menus (selecting kits, buying loot, class/kit selection, confirmations, teleport menus) using inventories rather than plain chat commands. |
| **Visuals: Particles, Holograms, Effects, Floating Texts**                | Libraries such as **HologramLib**, **Particle-native APIs**, or other effect/hologram helper libraries                                     | For boss effects, loot indicators, zone markers, floating texts (e.g. boss healthbars, loot chests, zone boundaries) â€” improves user experience. |
| **Data persistence / storage abstraction**                               | Generic storage libs (flat-file, JSON, YAML or DB wrappers), or lightweight DB abstractions (e.g. connection pooling helpers)               | To store persistent data: purchased kits, player progress, cooldowns, earned loot, settings â€” avoids reinventing file or database logic. |
| **General-purpose utilities (collections, JSON, serialization, helpers)**| Common Java libraries (e.g. Google Guava, Gson, Apache Commons Lang3) + server-shaded libs                                                 | Helps with miscellaneous tasks: collection utilities, JSON or object (de)serialization, string handling, common operations.     |
| **Item / metadata / NBT / Persistent Data Container helpers**             | **Item-NBT-API**, **MorePersistentDataTypes**, **adventure-nbt** (or similar)                                                             | Lets you attach custom data to items/entities without fragile raw-NMS/NBT code â€” useful for custom loot, persistent metadata, tracking state for items, players, mobs, etc. |
| **Protocol / packet-level / network manipulation**                       | **ProtocolLib**, **PacketEvents**, **MCProtocolLib**                                                                                     | Allows intercepting, modifying, or sending raw network packets â€” useful for custom visuals, fake entities/blocks, advanced client-side behavior, anti-cheat or custom UI/interaction systems. :contentReference[oaicite:0]{index=0} |
| **Chat / Message / Text / UI components (rich chat, JSON, interactive)**  | **Kyori Adventure** (and related text-component libraries: MiniMessage, etc.), **PlaceholderAPI**, **MineDown**    | Makes sending rich chat messages easier â€” supports color formatting, interactive messages (click/hover), JSON components, titles, boss-bars, etc. Improves UX compared to plain string messages. :contentReference[oaicite:2]{index=2} |

## ðŸ”Ž How to use this matrix when deciding libraries

- Identify **which features** you need (zones, kits, custom mobs, GUI menus, persistent loot, metadata, custom visuals, packet manipulation, etc.).  
- For each feature, look up the corresponding row (Domain / Purpose) and pick one or more libraries under it.  
- Combine libraries to cover multiple concerns cleanly (e.g. config + commands + GUI + persistence + metadata + visual effects).  
- Prefer higher-level libs where possible â€” only pull in packet/NMS or metadata-heavy libs if you really need low-level control or custom behavior.  
- For small/simple plugins, start minimal (core API + config + maybe command GUI); scale up to more libraries as complexity grows.  
