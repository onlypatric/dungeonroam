package com.patric.dungeonsroam;

import org.bukkit.configuration.ConfigurationSection;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.java.JavaPlugin;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.logging.Level;

/**
 * Persists player inventory snapshots generated by the RPG system.
 */
public final class PlayerDataManager {
    private final JavaPlugin plugin;
    private final File dataFile;
    private final YamlConfiguration configuration;
    private final Map<UUID, Map<String, InventorySnapshot>> storedSnapshots = new HashMap<>();

    public PlayerDataManager(JavaPlugin plugin) {
        this.plugin = plugin;
        this.dataFile = new File(plugin.getDataFolder(), "playerdata.yml");
        if (!dataFile.exists()) {
            try {
                dataFile.getParentFile().mkdirs();
                dataFile.createNewFile();
            } catch (IOException e) {
                plugin.getLogger().log(Level.SEVERE, "Failed to create playerdata.yml", e);
            }
        }
        this.configuration = YamlConfiguration.loadConfiguration(this.dataFile);
        loadSnapshots();
    }

    public Optional<InventorySnapshot> loadRpgSnapshot(UUID playerId, String world) {
        Map<String, InventorySnapshot> worldSnapshots = storedSnapshots.get(playerId);
        if (worldSnapshots == null) {
            return Optional.empty();
        }
        return Optional.ofNullable(worldSnapshots.get(world));
    }

    public void saveRpgSnapshot(UUID playerId, String world, InventorySnapshot snapshot) {
        storedSnapshots
                .computeIfAbsent(playerId, id -> new HashMap<>())
                .put(world, snapshot);
        storeSnapshot(playerId, world, snapshot);
        persistAsync();
    }

    public void flush() {
        saveToDisk();
    }

    private void loadSnapshots() {
        ConfigurationSection playersSection = configuration.getConfigurationSection("players");
        if (playersSection == null) {
            return;
        }
        for (String playerKey : playersSection.getKeys(false)) {
            UUID playerId;
            try {
                playerId = UUID.fromString(playerKey);
            } catch (IllegalArgumentException e) {
                continue;
            }
            ConfigurationSection playerSection = playersSection.getConfigurationSection(playerKey);
            if (playerSection == null) {
                continue;
            }
            ConfigurationSection rpgSection = playerSection.getConfigurationSection("rpg");
            if (rpgSection == null) {
                continue;
            }
            for (String world : rpgSection.getKeys(false)) {
                ConfigurationSection worldSection = rpgSection.getConfigurationSection(world);
                if (worldSection == null) {
                    continue;
                }
                InventorySnapshot snapshot = readSnapshot(worldSection);
                if (snapshot != null) {
                    storedSnapshots.computeIfAbsent(playerId, id -> new HashMap<>())
                            .put(world, snapshot);
                }
            }
        }
    }

    private InventorySnapshot readSnapshot(ConfigurationSection section) {
        if (section == null) {
            return null;
        }
        return new InventorySnapshot(
                toArray(section.getList("contents", Collections.emptyList())),
                toArray(section.getList("armor", Collections.emptyList())),
                toArray(section.getList("offhand", Collections.emptyList())),
                toArray(section.getList("enderchest", Collections.emptyList()))
        );
    }

    private ItemStack[] toArray(List<?> contents) {
        if (contents == null || contents.isEmpty()) {
            return null;
        }
        return contents.stream()
                .filter(item -> item instanceof ItemStack)
                .map(item -> ((ItemStack) item).clone())
                .toArray(ItemStack[]::new);
    }

    private List<ItemStack> toList(ItemStack[] items) {
        if (items == null) {
            return null;
        }
        return Arrays.stream(items)
                .map(item -> item == null ? null : item.clone())
                .toList();
    }

    private void storeSnapshot(UUID playerId, String world, InventorySnapshot snapshot) {
        ConfigurationSection playersSection = configuration.getConfigurationSection("players");
        if (playersSection == null) {
            playersSection = configuration.createSection("players");
        }
        ConfigurationSection playerSection = playersSection.getConfigurationSection(playerId.toString());
        if (playerSection == null) {
            playerSection = playersSection.createSection(playerId.toString());
        }
        ConfigurationSection rpgSection = playerSection.getConfigurationSection("rpg");
        if (rpgSection == null) {
            rpgSection = playerSection.createSection("rpg");
        }
        ConfigurationSection worldSection = rpgSection.getConfigurationSection(world);
        if (worldSection == null) {
            worldSection = rpgSection.createSection(world);
        }
        worldSection.set("contents", toList(snapshot.getContents()));
        worldSection.set("armor", toList(snapshot.getArmor()));
        worldSection.set("offhand", toList(snapshot.getOffHand()));
        worldSection.set("enderchest", toList(snapshot.getEnderChest()));
    }

    private void persistAsync() {
        plugin.getServer().getScheduler().runTaskAsynchronously(plugin, this::saveToDisk);
    }

    private void saveToDisk() {
        try {
            configuration.save(dataFile);
        } catch (IOException e) {
            plugin.getLogger().log(Level.SEVERE, "Failed to flush playerdata.yml", e);
        }
    }
}
